\hypertarget{index_intro_sec}{}\section{简介}\label{index_intro_sec}
Iris 2D 是一款开源的2\+D游戏引擎，旨在于进行快速轻量的游戏开发。

Iris 2D 提供了一个非常简洁的功能集合，能够支持大多数情况下最必要的开发需求，并且 Iris 2D 也提供了对扩展编写较为友好的接口，让开发或者能够自己实现更多的定制性功能。

Iris 2D 最主要的目的是简化 2D 游戏开发的操作，开发者不需要考虑与游戏本身无关的事情，只需要方便而直观地编写他们的逻辑代码。

大多数情况下， Iris 不会提供一个确切的游戏开发框架，相反，开发者将会触碰到游戏的基本元素比如游戏循环。然而，这个特性和 Iris 2D 的主要目标并不冲突，如果您实际地体验一下 Iris 2D 的话，你会发现一切都运行得很好。

通常情况下，\+Iris 2D 提供了3种开发方式供选择：

\begin{DoxyItemize}
\item 使用 C++ 以及 Iris 2D 的原生代码进行开发; \item 使用 C/\+C++ 以及 Iris 2D 导出的 A\+PI 进行开发; \item 使用 Iris programming language 开发。\end{DoxyItemize}
\begin{DoxyParagraph}{对于第一种方式：}
您会与 Iris 2D 的原生 C++ 代码一起工作，并且最终将整个 Iris 2D 的代码编译到开发者游戏的可执行文件之中。使用这种方法，开发者可以轻易地调试进 Iris 2D 的内部并且能够做任何想做的事情（比如自定义 Iris 2D 的核心功能）。相对的，这种方式需要开发者的 C++ 编译器支持 C++ 11 ，因为当前的 Iris 2D 是使用 C++ 11 开发的。同时，这种方式将会让您最终的可执行文件体积变得大。 
\end{DoxyParagraph}
\begin{DoxyParagraph}{对于第二种方式：}
Iris 2D 的代码将会被编译进一个动态链接库（.\+dll）之中并且附带一个导出函数库。使用这种方式，\+Iris 2D 的代码会从开发者的游戏代码中分离出来，并且最终的可执行文件的体积将会比使用方式1得到的可执行文件小得多。相对的，采用这种方式也就意味着开发者无法看到 Iris 2D 内部发生了什么并且只能够使用 Iris 2D 导出的 A\+PI 进行游戏开发 ： 事实上大多数开发者也并不需要知道这些内部工作。 
\end{DoxyParagraph}
\begin{DoxyParagraph}{}
此外，这种方式允许开发者采用 C/\+C++ 来开发游戏，而不是只能使用 C++ 。\+Iris 2D 可以分别为 C 和 C++ 导出2种风格的 A\+P\+I： 
\end{DoxyParagraph}
\begin{DoxyParagraph}{}
\begin{DoxyItemize}
\item 对于 C++ 风格，\+A\+PI 将会以基于虚函数表的方式被导出，就如同 C\+OM (Component Object Model) 所做的那样（不过并没有它那么复杂），所以如果开发者喜欢 O\+OP 的模式，那么就可以使用这套 A\+PI 。 \item 对于 C 风格，\+A\+PI 将会使用 H\+A\+N\+D\+LE 的风格被导出，这就如同 Win32 A\+PI 所做的那样，所以如果开发者只想要编写 C 代码而不是 C++ 代码，那么这个方式将会是最好的选项。\end{DoxyItemize}

\end{DoxyParagraph}
\begin{DoxyParagraph}{对于第三种方式：}
我们也为开发或者提供了一种仅仅使用脚本而无需编译就进行游戏开发的方式。 首先，这门脚本语言就是 Iris programming language ，这是一门面向对象的动态语言。对于该语言的更多信息，请访问：http\+://doc.irislang.\+org/ 。 
\end{DoxyParagraph}
\begin{DoxyParagraph}{}
其次，\+Iris 2D 将它的 A\+PI 导出给了 Iris programming language，于是开发者可以只编写 Iris programming language 的脚本就能够完成他们的游戏。 
\end{DoxyParagraph}
\begin{DoxyParagraph}{}
这种方式被提供给那些需要非常快速和简化的游戏开发的开发者们。 
\end{DoxyParagraph}
\hypertarget{index_install_sec_1}{}\section{如何使用原生 C++ 代码开始一个 Iris 2\+D 应用}\label{index_install_sec_1}
\begin{DoxyItemize}
\item 从github上clone工程 ~\newline
 {\ttfamily  git clone \href{https://github.com/yuwenhuisama/Iris-2D-Project.git}{\tt https\+://github.\+com/yuwenhuisama/\+Iris-\/2\+D-\/\+Project.\+git} }. \item 使用 Visual Studio 打开{\itshape  Iris 2D Cherry.\+sln }（推荐使用 Visual Studio 2017，更多信息请访问：https\+://www.visualstudio.\+com ) ~\newline
 {\bfseries  当前的 Iris 2D 只能够在 M\+S\+VC 上编译通过，所以如果您想要使用其他编译器的话，您需要修改一些代码。} \item 在{\ttfamily  解决方案管理器 } 中选择{\itshape  main.\+cpp }并清空里面的内容。 \item 编写代码 \+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include "Iris2D.h"}
\textcolor{keyword}{using namespace }\hyperlink{namespace_iris2_d}{Iris2D};

\textcolor{keywordtype}{bool} GameCallBack() \{
    \textcolor{keyword}{auto} pGraphics = \hyperlink{class_iris2_d_1_1_iris_graphics_a25533fd69478336d60c5b1f639802d3a}{IrisGraphics::Instance}();
    \textcolor{keyword}{auto} pApp = \hyperlink{class_iris2_d_1_1_iris_application_ab2a9826c10d90732f398859782817f8e}{IrisApplication::Instance}();
    \textcolor{keywordflow}{while} (!pApp->IsQuited()) \{
      pGraphics->Update();
    \}
    \textcolor{keywordflow}{return} \textcolor{keyword}{true};
\}

\textcolor{keywordtype}{int} WINAPI WinMain(HINSTANCE hInstance, HINSTANCE prevInstance, PSTR cmdLine, \textcolor{keywordtype}{int} showCmd) \{
    \hyperlink{struct_iris2_d_1_1_iris_application_1_1_iris_app_start_info}{IrisApplication::IrisAppStartInfo} iasiStartInfo = \{ hInstance, showCmd
      , 60, 60, 1600, 900, GameCallBack, L\textcolor{stringliteral}{"My Iris App"} \};
    \textcolor{keyword}{auto} pApp = \hyperlink{class_iris2_d_1_1_iris_application_ab2a9826c10d90732f398859782817f8e}{IrisApplication::Instance}(); 

    \textcolor{keywordflow}{if} (!pApp->Initialize(&iasiStartInfo)) \{
      pApp->Release();
      \textcolor{keywordflow}{return} -1;
      \}

    \textcolor{keywordflow}{if} (!pApp->Run()) \{
      pApp->Release();
      \textcolor{keywordflow}{return} -1;
    \}

    pApp->Release();
    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}
 \item 编译并运行.\end{DoxyItemize}
以上就是 Iris 2D 应用的基本结构。通常而言，开发者的游戏逻辑代码应该被放在 Game\+Call\+Back() 方法里面。 对于更多的关于开发的信息，您可以阅读 Iris 2D 的范例。\hypertarget{index_install_sec_2}{}\section{如何使用导出的 A\+P\+I 开始一个 Iris 2\+D 应用}\label{index_install_sec_2}
\begin{DoxyParagraph}{}
$<${\bfseries Under} {\bfseries construction$>$} 
\end{DoxyParagraph}
\hypertarget{index_install_sec_3}{}\section{如何使用 Iris programming language 开始一个 Iris 2\+D 应用。}\label{index_install_sec_3}
\begin{DoxyParagraph}{}
$<${\bfseries Under} {\bfseries construction$>$} 
\end{DoxyParagraph}
\hypertarget{index_name_stg}{}\section{关于旧版本}\label{index_name_stg}
正如您所见的，当前 Iris 2D 的版本被命名为 {\bfseries  Cherry }。事实上，\+Iris 2D 拥有3个旧版本，但是已经不再被推荐：

\begin{DoxyItemize}
\item Iris 2D Amethyst (Iris 2D Amethyst -\/ Steck 是原生代码版本 而 Iris 2D Amethyst -\/ Potato 是 D\+LL 版本); \item Iris 2D Biscuit (Iris 2D Amethyst -\/ Turkey 是原生代码版本 而 Iris 2D Biscuit -\/ Potato 是 D\+LL 版本, Iris 2D Biscuit -\/ Watermelon 是被弃用的版本); \item Iris 2D Cerise (Iris 2D Cherry 的前身, 已弃用);\end{DoxyItemize}
\hypertarget{index_thanks}{}\section{感谢}\label{index_thanks}
\begin{DoxyParagraph}{}
$<${\bfseries Under} {\bfseries construction$>$} 
\end{DoxyParagraph}
\hypertarget{index_cont_cprt}{}\section{联系方式以及版权}\label{index_cont_cprt}
\begin{DoxyParagraph}{}
如果您对 Iris 2D 有任何建议或者报告，请联系 \href{mailto:a1026121287@hotmail.com}{\tt a1026121287@hotmail.\+com}； 
\end{DoxyParagraph}
\begin{DoxyParagraph}{}
Iris 2D 是一个开源项目，基于 B\+S\+D2 许可证，请访问 \href{https://opensource.org/licenses/BSD-2-Clause}{\tt https\+://opensource.\+org/licenses/\+B\+S\+D-\/2-\/\+Clause} 以获得更多信息。 
\end{DoxyParagraph}
